//此算法由PKU栾小坤爸爸提供 挺简单的办法 我特么就想不到 很无奈 
// 经验教训 没事排个序 会简单很多；
//最初的做法是我以往处理这类题的做法 即把线段的左端点作为代表 每输入一个区间就把其涵盖的左端点计入数组，最后把数组去重复，计其中的数字个数即可。但是这么做是不对的。
//答案有可能32位，数组根本存不下这么多数。 此方法只适用于较少线段、较小区间。 
//这个适用于较少线段 较大区间或较小区间。先按左端点大小把所有点排序（右端点跟随左端点的位置变化）。 
//下一步，取第一条线段，用第二条及以后的判断是否重叠；重叠则合并两条线段，还是放在a[1][1] a[1][2]下；直到有跑出去的线段，则计算原来求得的线段长度，并把跑出去的线段作为新a[1][1] a[1][2]
//最后求出所有len即可。 
// 可行的原因：左端点的顺序。由于左端点排序了，因此通过上述算法，能找到在某个左端点下右端点的最大值； 并且一旦有左端点跳出原线段，之后的左端点也不会在原线段中。
//太牛逼了！我太弱了！ 
#include <iostream>
using namespace std;

int main(){
	int n=0,i=0,j=0,temp=0,max=0,len=0,temp2=0;
	int a[1001][3];
	cin >> n;
	for(i=1;i<=n;i++){
		cin >> a[i][1] >> a[i][2];
	}
	for(i=1;i<=n-1;i++){
		for(j=1;j<=n-i;j++){
			if(a[j][1]>a[j+1][1]){
				temp=a[j][1];
				a[j][1]=a[j+1][1];
				a[j+1][1]=temp;
				temp2=a[j][2];
				a[j][2]=a[j+1][2];
				a[j+1][2]=temp2;
			}
		}
    }
	for(i=2;i<=n;i++){
		if(a[i][1]<=a[1][2]){
			if(a[i][2]>a[1][2]){
				a[1][2]=a[i][2];
			}
		}
		else{
			len=len+a[1][2]-a[1][1];
			a[1][1]=a[i][1];
			a[1][2]=a[i][2];
		}
		if(i==n){
			len=len+a[1][2]-a[1][1];
			break;
		}
	}
	cout << len << endl;
	return 0;
} 
